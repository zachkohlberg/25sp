<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SER120 Note Handouts</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SER120 Note Handouts</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Weekly notes for SER120, intended for reading assignments between lectures.</p>
<p>Read the notes by the end of the week in which they were assigned, before the
next week's lecture. Write down your answers to any questions or practice
exercises given in the notes, and be prepared to answer those questions during
class.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week-1"><a class="header" href="#week-1">Week 1</a></h1>
<h2 id="terms"><a class="header" href="#terms">Terms</a></h2>
<p>These are Java-specific, and I'm more interested in helping you understand the
underlying concepts than giving rigorous or overly-technical definitions. You
can always find a more precise/thorough definition online if you'd like one.</p>
<ul>
<li><strong>Object</strong>: a combination of data (variables) and behaviors/capabilities
(functions)</li>
<li><strong>Class</strong>: the definition or blueprint for a type of object<sup class="footnote-reference"><a href="#1">1</a></sup></li>
<li><strong>Instance</strong>: an individual object created from a class definition</li>
<li><strong>Method</strong>: a function belonging to a class (its behaviors/capabilities),
which describes every Java function<sup class="footnote-reference"><a href="#2">2</a></sup></li>
<li><strong>Property</strong>: variable belonging to a class (its data), also called an
instance variable because each instance has its own copy of the variable</li>
<li><strong>Member</strong>: more general term for anything that belongs to a class (method,
property, etc.)</li>
<li><strong>Constructor</strong>: similar to a function, used to initialize the properties of a
new object</li>
<li><strong>Initialize</strong>: set a variable's initial value</li>
<li><strong>Instantiate</strong>: create a new instance of a class (a new object)</li>
<li><strong>Identifier</strong>: the name of a class, method, or variable</li>
</ul>
<p>Finally, you'll see the words <code>public</code> and <code>private</code> in most of our examples.
These are <strong>modifiers</strong>, keywords that appear at the beginning of class, method,
and variable declarations. We'll talk more about public, private, and modifiers
in general later, but for now we won't worry about them. Until then, our rule is
that all <strong>classes, methods, and constructors</strong> are <code>public</code> and all <strong>instance
variables</strong> are <code>private</code>.</p>
<h2 id="class-structure"><a class="header" href="#class-structure">Class Structure</a></h2>
<p>While the order within a class is flexible, it's good to stay organized. We'll
generally write our classes in this format:</p>
<pre><code class="language-java">public class MyClassName {
    // instance variables

    // constructors

    // methods
}
</code></pre>
<p>For example, let's write a Person class and a program that uses it:</p>
<pre><code class="language-java">// file: Main.java
public class Main {
    // the main method is where our program starts running
    // it is always public and static with a return type of void
    public static void main(String[] args) {
        // declare a local variable of type Person
        Person p;
        // instantiate a Person and use it to initialize the variable p
        p = new Person("Your Name Here");
        // call/invoke the sayName() method using the Person we just
        // instantiated
        p.sayName();
    }
}

// file: Person.java
public class Person {
    // instance variable
    private String name;

    // constructor
    public Person(String initName) {
        // initialize name
        name = initName;
    }

    // method
    public void sayName() {
        System.out.println("Hello, my name is " + name + "!");
    }
}
</code></pre>
<h3 id="syntax"><a class="header" href="#syntax">Syntax</a></h3>
<p>Below is the general syntax for what we saw in the above examples.</p>
<p>Class declaration</p>
<ul>
<li>filename must match class name if public</li>
<li>while we can have nested classes, for now we will declare one class per file</li>
</ul>
<pre><code>&lt;modifiers&gt; class &lt;identifier&gt; {
    &lt;body&gt;
}
</code></pre>
<p>Method declaration</p>
<ul>
<li>must be inside of a class body</li>
<li>cannot be inside another method or a constructor</li>
</ul>
<pre><code>&lt;modifiers&gt; &lt;return type&gt; &lt;identifier&gt;(&lt;parameters&gt;) {
    &lt;body&gt;
}
</code></pre>
<p>Constructor declaration</p>
<ul>
<li>must have the same identifier as the class</li>
<li>note that unlike a regular method, there is no return type</li>
<li>otherwise these follow the same rules as methods</li>
</ul>
<pre><code>&lt;modifiers&gt; &lt;identifier&gt;(&lt;parameters&gt;) {
    &lt;body&gt;
}
</code></pre>
<p>Instance variable declaration</p>
<ul>
<li>must be inside of a class body</li>
<li>cannot be inside a method or constructor</li>
</ul>
<pre><code>&lt;modifiers&gt; &lt;type&gt; &lt;identifier&gt;;
</code></pre>
<p>Instance variable declaration with initializer</p>
<ul>
<li>you can optionally initialize an instance variable in the same place you
declare it</li>
</ul>
<pre><code>&lt;modifiers&gt; &lt;type&gt; &lt;identifier&gt; = &lt;expression&gt;;
</code></pre>
<p>Invoke/call an instance method</p>
<ul>
<li>requires an instance of the class in which the method is defined</li>
<li>if the method returns something (return type isn't <code>void</code>), then this can be
used as an expression</li>
</ul>
<pre><code>&lt;instance identifier&gt;.&lt;method identifier&gt;(&lt;arguments&gt;)
</code></pre>
<p>Instantiate an object</p>
<ul>
<li>creates a new instance of a class</li>
<li>instantiating an object is an expression, and we usually want to assign it to
a variable as shown in the example</li>
<li>this is similar to a normal method invokation</li>
</ul>
<pre><code>new &lt;identifier&gt;(&lt;arguments&gt;)
</code></pre>
<h2 id="variables"><a class="header" href="#variables">Variables</a></h2>
<p>Variables fall into different categories depending on their scope, and these
categories serve different purposes. A variable's <strong>scope</strong> is the portion of
the program in which it exists. A variable's name should be unique within its
scope (there are exceptions), and it cannot be accessed or modified outside of
its scope.</p>
<h3 id="local-variable"><a class="header" href="#local-variable">Local Variable</a></h3>
<p>A local variable is declared within a method or a code block within a method.
Its scope is limited to the block in which it was declared.</p>
<pre><code class="language-java">public void scopeExample() {
    // x is a local variable and only valid until the end of main
    int x = 5;

    // we're placing an arbitrary code block here to create a smaller scope within main
    {
        // y is a local variable and only valid until the end of this block
        int y = 10;
        x = x * y;
    }

    // we can still access x, but we can no longer access y
    System.out.println(x);
    System.out.println(y); // ERROR!
}
</code></pre>
<h3 id="parameter"><a class="header" href="#parameter">Parameter</a></h3>
<p>A parameter (or formal parameter) appears in the paranthesis after a method's
name when declaring the method. It represents input required to invoke the
method, and its scope is limited to the body of the method.</p>
<p>When invoking a method, you must supply an argument (or actual parameter) for
each of that method's formal parameters. The arguments are the values used by
the method during that invokation.</p>
<pre><code class="language-java">public class ParamExample {
    public void example() {
        // calling add with the actual parameters x = 1, y = 2, and z = 3
        int sum = add(1, 2, 3);

        // calling println with the actual parameter "Sum = " + sum
        System.out.println("Sum = " + sum);

        // we cannot access x, y, or z outside of the add method
        System.out.println(x); // ERROR!
        System.out.println(y); // ERROR!
        System.out.println(z); // ERROR!
    }

    // add declares three formal parameters: x, y, and z
    public int add(int x, int y, int z) {
        return x + y + z;
    }
}
</code></pre>
<h3 id="instance-variable"><a class="header" href="#instance-variable">Instance Variable</a></h3>
<p>An instance variable is declared in the body of a class (not in one of its
methods or constructors), and it doesn't have the <code>static</code> modifier (more about
static when we discuss modifiers). Its scope is the body of its class.</p>
<p>Each instance of a class has its own separate copy of each instance variable
declared for that class. Those instance variables exist for as long as that
instance exists.</p>
<h2 id="footnotes"><a class="header" href="#footnotes">Footnotes</a></h2>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Java requires almost everything to be inside of a class, so we also use them
as containers for standalone functions (methods with the static modifier). A
single class can serve one or both of these purposes (blueprint or function
container). In SER120, we're usually talking about classes in their role as
a blueprint rather than function container.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Java does have lambdas (a functional programming concept), but I believe
these are implemented as methods of anonymous classes and still technically
qualify as methods. You don't need to know anything about lambdas or
functional programming in this class. I just like to use it as an example to
contrast with OOP.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week-2"><a class="header" href="#week-2">Week 2</a></h1>
<h2 id="mutability"><a class="header" href="#mutability">Mutability</a></h2>
<p>If something can change (mutate), then it is <strong>mutable</strong>. If something cannot
change, then it is <strong>immutable</strong>. If a class prevents any change to its
properties after instantiation, then we would consider it to be an immutable
type. If a class can change its properties after instantiation, then it is a
mutable type. For example: Java's built-in <code>String</code> class is immutable because
we cannot modify any properties of a string after we create it, whereas every
array is mutable (even if its individual elements are immutable) because we can
reassign the individual elements of an array.</p>
<h2 id="value-and-reference-types"><a class="header" href="#value-and-reference-types">Value and Reference Types</a></h2>
<p>Java has a set of basic "primitive" or <strong>value</strong> types: <code>byte</code>, <code>short</code>, <code>int</code>,
<code>long</code>, <code>char</code>, <code>float</code>, <code>double</code>, and <code>boolean</code>. By convention, these types
start with a lowercase letter. Every other type in Java is an object, or
reference type. These are defined by classes, and by convention their names
begin with an uppercase letter.</p>
<p>The word "value" may refer to the contents of a variable or the result of an
expression. The difference between a value type and reference type is what that
value represents:</p>
<ul>
<li>In a value type, the value <em>is</em> the data (such as the number 5, or the letter
'q')</li>
<li>In a reference type, the value is a reference to the data</li>
</ul>
<p>Instead of storing an object's data directly in a variable, the object's data is
stored in an area of memory called the heap. The variable instead stores a
reference to that object: a number pointing to its location on the heap (this
number is also called a pointer or memory address).</p>
<p>Two important differences between reference and value types to keep in mind:</p>
<ul>
<li>Assigning one reference variable to another (<code>Person b = a;</code>) will copy the
<em>reference</em>, not the object that the reference points to. This means multiple
variables can point to the same object. This can cause problems when the
object is mutable.</li>
<li>Direct comparisons using <code>==</code> and <code>!=</code> will compare the reference, not the
object that the reference points to. This means that two different objects
with identical properties will not be considered equal when using <code>==</code> and
<code>!=</code>. If a class implements its own <code>.equals()</code> method, then you can get
around this by comparing instances of that class with the <code>.equals()</code> method.</li>
</ul>
<h3 id="dereferencing"><a class="header" href="#dereferencing">Dereferencing</a></h3>
<p>As objects, reference types usually contain variables and methods. We can access
these with the <strong>dot operator</strong> (a period). This causes Java to follow the
reference to the object on the heap so that it can access the variable or method
after the dot operator. This process is called "dereferencing."</p>
<h3 id="null-references-and-default-values"><a class="header" href="#null-references-and-default-values">Null References and Default Values</a></h3>
<p>Every type has a default value. The default value for <code>boolean</code> is <code>false</code>, and
for every other primitive type it is the number zero. Reference types have a
default value of <code>null</code>, which is a reference that doesn't point to anything.</p>
<p>There are many situations in which you want a value to be <code>null</code>. For example,
if a method searches a list of accounts for one with a particular name,
returning <code>null</code> is a good way to indicate that it failed to find a matching
account.</p>
<p>There are also many situations where you would never want a value to equal
<code>null</code>. If such a value ever is <code>null</code>, then you're likely to encounter a
<a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/NullPointerException.html"><code>NullPointerException</code></a>.
A null pointer exception most often occurs when you attempt to dereference a
variable that is equal to <code>null</code>. If the variable doesn't point to an object,
then there's no way to access the variable or method you were trying to access,
and that instruction cannot be executed.</p>
<h2 id="inheritance"><a class="header" href="#inheritance">Inheritance</a></h2>
<p>One of the main features of OOP is inheritance. Inheritance allows you to define
a class that <strong>extends</strong> an existing class, which means your class will inherit
the properties and methods of that other class. Every class you write extends
exactly one other class: either the class you specify, or the
<a href="https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/lang/Object.html"><code>Object</code></a>
class if you don't specify anything.</p>
<p>Inheritance creates a hierarchy among all classes in a program. The <code>Object</code>
class is the root of that hierarchy, with every other class either extending
<code>Object</code> or one of its subclasses. Before we continue, let's define a few new
terms:</p>
<ul>
<li><strong>Extend</strong>: The Java keyword used to state that one class inherits from
another. If class B extends class A, then class B inherits all of the
variables and methods defined in class A.</li>
<li><strong>Subclass</strong>: A class that extends another class or one of its subclasses. If
class B extends class A, then B is a subclass of A. If class C extends class
B, then it is a subclass of both A and B.</li>
<li><strong>Superclass</strong>: A class that is extended by another class or by one of its
superclasses. In the previous example with classes A, B, and C, A is the
superclass of both B and C, and B is the superclass of C.</li>
</ul>
<p>Example classes from the above definitions:</p>
<pre><code class="language-java">// A implicitly extends Object because it does not state which class it extends
// A is a subclass of Object, and it is the superclass of B and C
class A {}

// B explicitly extends A
// B is a subclass of Object and A, and it is the superclass of C
class B extends A {}

// C explicitly extends B
// C is a subclass of Object, A, and B
class C extends B {}
</code></pre>
<h2 id="signatures-overloading-and-overriding"><a class="header" href="#signatures-overloading-and-overriding">Signatures, Overloading, and Overriding</a></h2>
<p>A constructor or method's <strong>signature</strong> consists of its name and parameter types
(in the order they were declared). This signature is important when discussing
overloading and overriding.</p>
<h3 id="overloading"><a class="header" href="#overloading">Overloading</a></h3>
<p>A class can declare multiple constructors and multiple methods with the same
name as long as their signatures still differ. This is called <strong>overloading</strong>.
For example, the <code>println</code> method you're used to using for command line output
is overloaded to allow either a <code>String</code> or zero parameters (along with other
overloads). This is why you can write both <code>System.out.println();</code> and
<code>System.out.println("Hello, I'm a String!");</code>.</p>
<p>Each overloaded method must have a different signature so that the compiler can
determine which version of the method is being invoked. That's why the following
program won't compile:</p>
<pre><code class="language-java">public class BadOverload {
    public static void main(String[] args) {
        // Which version of mystery are we calling? It's impossible to tell!
        System.out.println(mystery(10, 10));
    }

    public static int mystery(int a, int b) {
        return a + b;
    }

    public static int mystery(int a, int b) {
        return a * b;
    }
}
</code></pre>
<h3 id="overriding"><a class="header" href="#overriding">Overriding</a></h3>
<p>If a class inherits a method from another class, then it can provide its own
implementation of this method that differs from the implementation in its
superclass. This is called <strong>overriding</strong>. The signature of the new
implementation must be identical to the inherited method you wish to override.</p>
<p>When overriding a method, it's good to mark the method with the @Override
annotation. This will generate a compilation error if you do not correctly
override the method. Without this, you may not realize that you haven't
overridden the method and have a more difficulty time finding the bug.</p>
<p>It is common to override the <code>toString</code> and <code>equals</code> methods that every class
inherits from <code>Object</code>. These allow you to print your object in a readable form
and use <code>equals</code> to compare different instances and determine whether they are
equivalent. The example below demonstrates this:</p>
<pre><code class="language-java">public class Point {
    private int x, y;

    public Point(int initX, int initY) {
        x = initX;
        y = initY;
    }

    @Override
    public String toString() {
        return String.format("(%d,%d)", x, y);
    }

    @Override
    public boolean equals(Object other) {
        if (other == null || !(other instanceof Point)) {
            return false;
        }

        // must perform a typecast to treat the other object as a point
        Point otherPoint = (Point) other;
        return x == otherPoint.x &amp;&amp; y == otherPoint.y;
    }
}

public class Main {
    public static void main(String[] args) {
        Point a = new Point(1, 2);
        Point b = new Point(3, 4);
        Point c = new Point(1, 2);

        // printing or concatenating an object automatically calls its toString
        // method, giving us more readable output
        System.out.println("a: " + a);
        System.out.println("b: " + b);
        System.out.println("c: " + c);

        // comparing references results in false for equivalent points
        System.out.println("a == c results in: " + (a == c));
        // comparing with .equals results in true for equivalent points
        System.out.println("a.equals(c) results in: " + a.equals(c));
    }
}
</code></pre>
<h2 id="constructors-and-superclass-methods"><a class="header" href="#constructors-and-superclass-methods">Constructors and Superclass Methods</a></h2>
<p>Every class must have at least one constructor, and a class does not inherit any
constructors from its superclass<sup class="footnote-reference"><a href="#1">1</a></sup>. However, Java will add a <strong>default
constructor</strong> (one with no parameters) for you in the following situation:</p>
<ul>
<li>Your superclass defines a default constructor</li>
<li>Your class does not explicitly define a constructor</li>
</ul>
<p>Every constructor in Java also starts by calling a constructor in its
superclass. You can do this explicitly with the <code>super</code> keyword, but Java will
add a call to the superclass's default constructor for you in the following
situation:</p>
<ul>
<li>Your superclass defines a default constructor</li>
<li>Your constructor does not explicitly call a constructor from the superclass</li>
</ul>
<p>The following example demonstrates what Java adds for you:</p>
<pre><code class="language-java">// minimal class
public class A {}

// equivalent class, but explicitly showing what the compiler adds
public class A extends Object { // compiler would have extended Object for us
    public A() { // compiler would have added default constructor for us
        super(); // compiler would have called super() for us
    }
}

// another class
public class B extends Object {
    public B() {
        System.out.println("B");
    }
}

// and the equivalent with compiler addition
public class B extends Object {
    public B() {
        super(); // compiler would have called super() for us

        System.out.println("B");
    }
}
</code></pre>
<h2 id="footnotes-1"><a class="header" href="#footnotes-1">Footnotes</a></h2>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>While your class may have multiple superclasses above it in the hierarchy,
when we say "superclass" with no further context we usually mean the class
yours is directly extending.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="week-3"><a class="header" href="#week-3">Week 3</a></h1>
<h2 id="modifiers"><a class="header" href="#modifiers">Modifiers</a></h2>
<p>We've already seen several different modifier keywords in our Java programs.
Let's talk about what they mean.</p>
<h3 id="access-modifiers"><a class="header" href="#access-modifiers">Access Modifiers</a></h3>
<p>Access modifiers determine which parts of a program have access to something.
We've already used <code>public</code> and <code>private</code>, but there is also a <code>protected</code>
access modifier and the default "package private" level of access you get with
no modifier.</p>
<p>To describe these access levels:</p>
<ul>
<li><code>public</code> members can be accessed from anywhere</li>
<li><code>protected</code> members can be accessed from their class, package, or a subclass</li>
<li>"package private" (no modifier) members can be accessed from their class or
package</li>
<li><code>private</code> members can only be accessed from their class</li>
</ul>
<p>These access modifiers allow us to encapsulate code: hide implementation details
from users (other programmers) of a class and only expose the portions of the
class they need in order to use it.</p>
<p>Oracle's
<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html">access control tutorial</a>
explains these in more detail. Below is a table from the tutorial summarizing
the different access modifiers.</p>
<div class="table-wrapper"><table><thead><tr><th>Modifier</th><th>Class</th><th>Package</th><th>Subclass</th><th>World</th></tr></thead><tbody>
<tr><td><code>public</code></td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
<tr><td><code>protected</code></td><td>Yes</td><td>Yes</td><td>Yes</td><td>No</td></tr>
<tr><td><em>no modifier</em></td><td>Yes</td><td>Yes</td><td>No</td><td>No</td></tr>
<tr><td><code>private</code></td><td>Yes</td><td>No</td><td>No</td><td>No</td></tr>
</tbody></table>
</div>
<p>The tutorial also includes a small diagram with a class fitting each of the
above categories (class, package, subclass, world). I've included code below for
classes that fit the diagram and demonstrate where a variable with each modifier
can be accessed.</p>
<pre><code class="language-java">// file: one/Alpha.java
package one;

public class Alpha {
  public int a = 1;
  protected int b = 2;
  int c = 3;
  private int d = 4;

  public static void main(String[] args) {
    Alpha example = new Alpha();
    // can access everything from inside of MyClass
    System.out.println(example.a);
    System.out.println(example.b);
    System.out.println(example.c);
    System.out.println(example.d);
  }
}

// file: one/Beta.java
package one;

public class Beta {
  public static void main(String[] args) {
    Alpha example = new Alpha();
    // can access public, protected, and no modifier from another class in the same package
    System.out.println(example.a);
    System.out.println(example.b);
    System.out.println(example.c);
    // cannot access private from another class in the same package
    // System.out.println(example.d);
  }
}

// file: two/AlphaSub.java
package two;

public class AlphaSub extends one.Alpha {
  public static void main(String[] args) {
    one.Alpha example = new one.Alpha();
    // can access public and protected from a subclass class in another package
    System.out.println(example.a);
    System.out.println(example.b);
    // cannot access no modifier and private from a subclass class in another package
    // System.out.println(example.c);
    // System.out.println(example.d);
  }
}

// file: two/Gamma.java
package two;

public class Gamma {
  public static void main(String[] args) {
    one.Alpha example = new one.Alpha();
    // can only access public from an unrelated class in another package
    System.out.println(example.a);
    // cannot access protected, no modifier, or private from an unrelated class in another package
    // System.out.println(example.b);
    // System.out.println(example.c);
    // System.out.println(example.d);
  }
}
</code></pre>
<h3 id="static-vs-instance"><a class="header" href="#static-vs-instance">Static vs Instance</a></h3>
<p>We've also seen the <code>static</code> modifier before. A static member belongs to the
class as a whole, whereas a non-static (instance) member belongs to instances of
the class, each of which has its own copy of the non-static member.</p>
<p>We often use the <code>static</code> modifier when we want to write a method that can be
called without an instance of its class. We access static members by typing the
<em>class</em> name rather than the name of an instance of that class. We also use the
<code>static</code> modifier when creating <a href="week3.html#constants">constants</a>. If you've used the
<code>Math</code> class before, then you already know how to access static methods and
variables:</p>
<pre><code class="language-java">// We access the static constant PI and static method pow through the Math class:
double piSquared = Math.pow(Math.PI, 2);

// It would be strange if we had to instantiate Math to access its constants and methods:
Math m = new Math();
double piSquared = m.pow(m.PI, 2);
</code></pre>
<h3 id="constants"><a class="header" href="#constants">Constants</a></h3>
<p>The <code>final</code> modifier marks a variable as a constant. If a variable is final,
then it cannot be reassigned once it is initialized. However, if the variable
references a mutable object, then the object itself is still mutable. For
example:</p>
<pre><code class="language-java">final int[] array = new int[] { 1, 2, 3 };

// we cannot reassign a final variable
array = new int[] { 4, 5, 6 }; // error

// we can, however, mutate the array assigned to a final variable
array[0] = 10; // no error
</code></pre>
<h2 id="abstract-classes"><a class="header" href="#abstract-classes">Abstract Classes</a></h2>
<p>We've seen some examples of inheritance where we have a more generic "base"
type, such as "Pet", and specific subtypes, such as "Dog" and "Cat". In cases
like this, it may not make sense to define all of the methods we want to include
in our subclasses. It also may not make sense to instantiate this vague base
class. This is a situation where we may want to use an abstract class.</p>
<p>The <code>abstract</code> keyword is another modifier. When applied to a class, it allows
the class to contain abstract methods and does not allow the class to be
instantiated. When applied to a method, it allows us to leave out the method
definition. Instead, we'll rely on any subclasses to define their own version of
the abstract method. A non-abstract class (the classes we've seen so far) can
also be called a <strong>concrete</strong> class.</p>
<p>Here's an abstract version of the <code>Pet</code> class from our previous activity:</p>
<pre><code class="language-java">public abstract class Pet {
  private String name;

  public Pet(String name) {
    this.name = name;
  }

  public String getName() {
    return this.name;
  }

  public abstract String getSound();

  public void speak() {
    System.out.println(getName() + " says " + getSound());
  }
}
</code></pre>
<p>We can extend this class just like we did in the activity, but we are now
<em>required</em> to override the abstract <code>getSound</code> method we inherit from Pet. We
want to include that requirement so that our <code>speak</code> method can call the
subclass's implementation of <code>getSound</code>. It also lets us skip putting a
meaningless default <code>getSound</code> implementation in our <code>Pet</code> class, as you saw in
the activity's starter code.</p>
<h2 id="wheels"><a class="header" href="#wheels">Wheels</a></h2>
<p>We're going to use a graphics library called wheels to get started writing
graphical programs. It's an old library intended for educational use, and it
simplifies the process of creating a graphical program in Java. We will switch
to using a more standard library, swing, later in the semester.</p>
<h3 id="wheels-documentation"><a class="header" href="#wheels-documentation">Wheels Documentation</a></h3>
<p>You can download the wheels library and documentation from Blackboard or our
shared OneDrive folder. The wheels documentation is a website generated with the
<code>javadoc</code> program, which is also used to generate the
<a href="https://docs.oracle.com/en/java/javase/23/docs/api/index.html">Java API</a>. To
view the documentation, unzip the wheels-docs folder and open <code>index.html</code> in
your web browser.</p>
<h3 id="wheels-projects"><a class="header" href="#wheels-projects">Wheels Projects</a></h3>
<p>If you're using Eclipse, then you can add the wheels library to a project by
right-clicking on the project, selecting "Build Path", selecting "Add External
Archives", locating and selecting the wheels.zip file you downloaded, and
clicking "Open".</p>
<p>If you're running your program on the terminal, then you can either include
wheels.zip on your classpath or add a copy to the same folder as your code. If I
were keeping wheels.zip in my <code>ser120/</code> directory and my program was in my
<code>ser120/practice/week3/</code> directory, then I could run <code>Main.java</code> with the
command <code>java -cp "../../wheels.zip" Main.java</code>.</p>
<p>You can use the sample program below to check whether you've imported wheels
correctly. It should display a window with a quit button.</p>
<pre><code class="language-java">public class Main extends wheels.users.Frame {
  public static void main(String[] args) {
    new Main();
  }
}
</code></pre>
<p>If a class extends the <code>Frame</code> class in the wheels library, then instantiating
that class will create a window. Any shapes instantiated by that class will
appear in the window. Add the following constructor to <code>Main.java</code> and you
should see a red circle in the middle of the window:</p>
<pre><code class="language-java">public Main() {
  new wheels.users.Ellipse();
}
</code></pre>
<p>The <code>wheels.users</code> portion of the name specifies the package containing the
<code>Frame</code> and <code>Ellipse</code> classes. You can import <code>wheels.users.Frame</code> and
<code>wheels.users.Ellipse</code> to avoid having to type the package as part of the type:</p>
<pre><code class="language-java">import wheels.users.Ellipse;
import wheels.users.Frame;

public class Main extends Frame {
  private Ellipse ellipse;
  public Main() {
    ellipse = new Ellipse();
  }

  public static void main(String[] args) {
    new Main();
  }
}
</code></pre>
<p>We'll use wheels in many of our example programs to add a visual element to the
object-oriented concepts we're learning.</p>
<h2 id="composition"><a class="header" href="#composition">Composition</a></h2>
<p>Like inheritance, composition is another technique that allows us to reuse code.
Instead of extending a common superclass, we can put the code we want to reuse
in a separate class and include an instance of that separate class as a
property.</p>
<p>For example, we might want classes for a Student and Worker. Both classes will
have a bank account, and we would like to avoid duplicating the code for
managing the bank account. An inheritance solution might look like this:</p>
<pre><code class="language-java">public class PersonWithBankAccount {
  private int balance;

  public void deposit(int amount) {
    balance += amount;
  }

  public int withdraw(int amount) {
    if (balance &gt;= amount) {
      balance -= amount;
      return amount;
    } else {
      return 0;
    }
  }
}
public class Student extends PersonWithBankAccount {
  public void buyTextbook(int cost) {
    int cash = withdraw(cost);
    if (cash == cost) {
      System.out.println("Bought the books.");
    } else {
      System.out.println("Couldn't buy the books.");
    }
  }
}
public class Worker extends PersonWithBankAccount {
  public void depositPaycheck(int amount) {
    deposit(amount);
    System.out.println("Deposited paycheck.");
  }
}
</code></pre>
<p>A composition solution would look like this:</p>
<pre><code class="language-java">public class BankAccount {
  private int balance;

  public void deposit(int amount) {
    balance += amount;
  }

  public int withdraw(int amount) {
    if (balance &gt;= amount) {
      balance -= amount;
      return amount;
    } else {
      return 0;
    }
  }
}
public class Student {
  private BankAccount account;

  public void buyTextbook(int cost) {
    int cash = account.withdraw(cost);
    if (cash == cost) {
      System.out.println("Bought the books.");
    } else {
      System.out.println("Couldn't buy the books.");
    }
  }
}
public class Worker {
  private BankAccount account;

  public void depositPaycheck(int amount) {
    account.deposit(amount);
    System.out.println("Deposited paycheck.");
  }
}
</code></pre>
<p>This is a simple example, and there's not a huge difference between the two
versions. However, on a larger scale, we can encounter some problems with the
inheritance version. Remember that each class extends <em>exactly</em> one other class.
What if we want to reuse code from two different classes? If these classes are
in different parts of the class hierarchy, then we can't extend both of them.
Composition doesn't have this limitation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
